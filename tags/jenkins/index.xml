<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins on See Hiong&#39;s Blog</title>
    <link>https://seehiong.github.io/tags/jenkins/</link>
    <description>Recent content in Jenkins on See Hiong&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 18 Jul 2021 20:00:00 +0800</lastBuildDate>
    <atom:link href="https://seehiong.github.io/tags/jenkins/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CI/CD Pipeline on Pi Cluster (IV)</title>
      <link>https://seehiong.github.io/posts/2021/07/ci/cd-pipeline-on-pi-cluster-iv/</link>
      <pubDate>Sun, 18 Jul 2021 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2021/07/ci/cd-pipeline-on-pi-cluster-iv/</guid>
      <description>In the fourth part of my Raspberry Pi CI/CD pipeline series, I integrated SonarQube into the workflow for continuous code quality and security. I installed SonarQube on my Raspberry Pi Cluster, utilizing a custom Docker image. Additionally, I replaced Gitea with Gitlab for enhanced compatibility with SonarQube. I built and deployed Gitlab on the cluster, managing persistent storage with Longhorn volumes. For seamless integration, I configured Gitlab settings, created a Jenkins user, and set up access tokens. Lastly, I prepared Jenkins by installing necessary plugins and establishing connections with Gitlab. The result is an extended CI/CD pipeline with SonarQube, Jenkins, and Gitlab on a Raspberry Pi Cluster.</description>
    </item>
    <item>
      <title>CI/CD Pipeline on Pi Cluster (III)</title>
      <link>https://seehiong.github.io/posts/2021/07/ci/cd-pipeline-on-pi-cluster-iii/</link>
      <pubDate>Sun, 04 Jul 2021 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2021/07/ci/cd-pipeline-on-pi-cluster-iii/</guid>
      <description>In the third part of my Raspberry Pi CI/CD pipeline series, I incorporated JFrog Container Registry. Following the previous guide, I installed the registry, configured Docker images, and set up Longhorn volumes. Configuring the JFrog Container Registry involved adding local repositories, setting permissions, and configuring HTTP settings. I demonstrated testing the registry with Docker login and pushing an image. For Kubernetes integration, I created registry secrets and updated deployment files. The result is a complete CI/CD pipeline on a Raspberry Pi Cluster with JFrog Container Registry supporting Docker images. Optional Jenkins configuration is provided for maven-agent support.</description>
    </item>
    <item>
      <title>CI/CD Pipeline on Pi Cluster (II)</title>
      <link>https://seehiong.github.io/posts/2021/06/ci/cd-pipeline-on-pi-cluster-ii/</link>
      <pubDate>Mon, 21 Jun 2021 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2021/06/ci/cd-pipeline-on-pi-cluster-ii/</guid>
      <description>In the second installment of my Raspberry Pi CI/CD pipeline series, I seamlessly integrated JFrog Artifactory. Following the groundwork laid in [Part I], I extended the pipeline by configuring Maven-agent for Longhorn volume mounting, building a Raspberry Pi-compatible Artifactory Docker image, and configuring Artifactory. I demonstrated the process of creating permissions, Maven settings, and deploying JAR files. The integration with Jenkins involved plugin installation, settings configuration, and Jenkinsfile creation for artifact deployment. The result is a robust CI/CD pipeline on a Raspberry Pi Cluster, efficiently deploying artifacts to Artifactory. Troubleshooting tips address Longhorn volume stability and Jenkins volume permission issues.</description>
    </item>
    <item>
      <title>CI/CD Pipeline on Pi Cluster (I)</title>
      <link>https://seehiong.github.io/posts/2021/06/ci/cd-pipeline-on-pi-cluster-i/</link>
      <pubDate>Sun, 13 Jun 2021 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2021/06/ci/cd-pipeline-on-pi-cluster-i/</guid>
      <description>In this series, I documented my journey building a CI/CD pipeline on a Raspberry Pi Cluster, featuring 3 master and 1 worker nodes, all housed in a custom LEGO structure. The setup includes tools like Metallb for load balancing, along with specific volumes for MySQL, Gitea, Jenkins, and Maven-agent. I detailed the installation processes for MySQL, Gitea, Jenkins, and Maven-agent, complete with YAML deployment files. The configuration steps for Jenkins, both for Kubernetes and Gitea integration, were outlined. The troubleshooting section covers issues related to Kubernetes connection errors and finding the Jenkins initial admin password. The final result showcases a functional CI/CD pipeline: when code is committed, it triggers the CI pipeline, with the Maven-agent building and compiling the code successfully.</description>
    </item>
    <item>
      <title>Jenkins Maven Agent</title>
      <link>https://seehiong.github.io/posts/2020/07/jenkins-maven-agent/</link>
      <pubDate>Fri, 31 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/jenkins-maven-agent/</guid>
      <description>I&amp;rsquo;ve successfully created a Jenkins Maven Agent for my Kubernetes Cluster, significantly improving Maven build times. Configuring Jenkins involved adding a pod template named maven with specific container and volume settings. I created a persistent volume and claims for the Maven repository, reducing build times for subsequent executions. Troubleshooting included resolving errors related to missing persistent volume claims and ownership issues. Now, my Jenkins builds efficiently leverage a local Maven repository within the Kubernetes environment, resulting in faster and more efficient Maven builds.</description>
    </item>
    <item>
      <title>Jenkins Pipeline for K8s Cluster</title>
      <link>https://seehiong.github.io/posts/2020/07/jenkins-pipeline-for-k8s-cluster/</link>
      <pubDate>Fri, 31 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/jenkins-pipeline-for-k8s-cluster/</guid>
      <description>I effortlessly set up a Jenkins Pipeline for my Kubernetes Cluster, enabling seamless continuous integration for my projects. Following my previous post on integrating Jenkins and Gitea, I configured Git and Gitea, creating a declarative Jenkins pipeline. With Gitea webhooks triggering builds on Git commits, I successfully tested the pipeline for a Spring Boot Hello-World application. The pipeline integrates with Git, Maven, and Gitea, ensuring efficient builds and synchronization with each commit. Troubleshooting tips address potential issues, providing a smooth Jenkins experience. Next, I plan to enhance Maven build times in my upcoming guide.</description>
    </item>
    <item>
      <title>Integrating Jenkins and Gitea</title>
      <link>https://seehiong.github.io/posts/2020/07/integrating-jenkins-and-gitea/</link>
      <pubDate>Sun, 26 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/integrating-jenkins-and-gitea/</guid>
      <description>I seamlessly integrated Jenkins and Gitea, establishing full control over my self-hosted continuous integration (CI) environment. I installed the Gitea plugin on Jenkins, configured Gitea, and set up Jenkins to recognize the Gitea organization. The integration allows automatic build triggers upon committing to the Gitea repository. Additionally, I tested the webhook connection for smooth functionality. With this setup, I&amp;rsquo;m ready to dive into the CI workflow for my Spring Boot application in the upcoming post. Stay tuned for more!</description>
    </item>
    <item>
      <title>Jenkins for K8s Cluster (II)</title>
      <link>https://seehiong.github.io/posts/2020/07/jenkins-for-k8s-cluster-ii/</link>
      <pubDate>Sun, 19 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/jenkins-for-k8s-cluster-ii/</guid>
      <description>I&amp;rsquo;ve successfully set up Jenkins Agents for my Kubernetes Cluster, enhancing its capabilities for automated build, test, and scalable deployment pipelines. Following Docker image creation for the Jenkins agent on the Raspberry Pi, I configured Jenkins for scalability. Adjustments included setting the inbound agent protocol and configuring Kubernetes cloud settings. Creating Jenkins jobs and scheduling builds demonstrated the functionality, with agents initially suspended and later executing jobs successfully. The troubleshooting tip highlighted the importance of naming the container as jnlp. My Jenkins on Kubernetes Cluster is now fully operational, ready for future pipeline configurations.</description>
    </item>
    <item>
      <title>Jenkins for K8s Cluster (I)</title>
      <link>https://seehiong.github.io/posts/2020/07/jenkins-for-k8s-cluster-i/</link>
      <pubDate>Sun, 12 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/jenkins-for-k8s-cluster-i/</guid>
      <description>I&amp;rsquo;ve successfully set up Jenkins on my Kubernetes Cluster, streamlining build, test, and deployment pipelines. Following a Docker image creation for Jenkins on the Raspberry Pi, I deployed it to the Kubernetes Cluster. Troubleshooting involved building a custom Docker image due to ARM architecture limitations. Additionally, I addressed a service account error by creating the necessary role and role binding. Now, I can access Jenkins and proceed to configure Jenkins Agents for Kubernetes in the next post, enhancing automation within my cluster.</description>
    </item>
  </channel>
</rss>
