<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts from 2020 on See Hiong&#39;s Blog</title>
    <link>https://seehiong.github.io/posts/2020/</link>
    <description>Recent content in Posts from 2020 on See Hiong&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 17 Aug 2020 20:00:00 +0800</lastBuildDate>
    <atom:link href="https://seehiong.github.io/posts/2020/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HA K8s Pi Cluster (II)</title>
      <link>https://seehiong.github.io/posts/2020/08/ha-k8s-pi-cluster-ii/</link>
      <pubDate>Mon, 17 Aug 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/08/ha-k8s-pi-cluster-ii/</guid>
      <description>In my journey to establish a Highly Available Kubernetes Pi Cluster, I&amp;rsquo;ve successfully configured the cluster following an external etcd setup. The process involves installing Docker, setting up the Docker daemon, and installing kubeadm. Initializing Kubernetes Master Nodes, preparing certificates, and configuring Calico for networking are key steps. Troubleshooting tips include addressing refused connections and certificate expiration. To rejoin a faulty node, cordoning, draining, and generating new keys are essential. Now, I proudly own a fully operational Highly Available Kubernetes Pi Cluster.</description>
    </item>
    <item>
      <title>HA K8s Pi Cluster (I)</title>
      <link>https://seehiong.github.io/posts/2020/08/ha-k8s-pi-cluster-i/</link>
      <pubDate>Sun, 09 Aug 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/08/ha-k8s-pi-cluster-i/</guid>
      <description>In this special guide, I celebrate Singapore&amp;rsquo;s 55th National Day by setting up a Highly Available Kubernetes Pi Cluster using 2x Raspberry Pi Model B 8GB. With a total setup time of 25 minutes, I configure an external etcd key-value store, laying the foundation for high availability. I detail OS preparation, creating a virtual IP with Keepalived, generating certificates for etcd, and setting up etcd on each master node. Troubleshooting tips are provided, including addressing cluster ID mismatches and replacing faulty members. Stay tuned for the next article covering the continuation of the HA configuration.</description>
    </item>
    <item>
      <title>Private Registry for K8s Cluster</title>
      <link>https://seehiong.github.io/posts/2020/08/private-registry-for-k8s-cluster/</link>
      <pubDate>Fri, 07 Aug 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/08/private-registry-for-k8s-cluster/</guid>
      <description>I&amp;rsquo;ve successfully set up my Private Registry for the Kubernetes Cluster on Raspberry Pi. With this, I have full control over the Docker registry, enhancing overall performance. The process involves creating a self-signed certificate, installing it on master and leaf nodes, and deploying the registry. Utilizing the private registry with Jenkins is seamless: tagging, pushing, and pulling images. Troubleshooting tips include updating the hosts file and trusting the certificate at the OS level. Now, my Kubernetes Cluster benefits from a personalized, efficient private registry.</description>
    </item>
    <item>
      <title>OpenWrt Router on Pi 3</title>
      <link>https://seehiong.github.io/posts/2020/08/openwrt-router-on-pi-3/</link>
      <pubDate>Sun, 02 Aug 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/08/openwrt-router-on-pi-3/</guid>
      <description>I&amp;rsquo;ve successfully configured OpenWrt Router on my Raspberry Pi 3, enhancing customization for my application needs. The process involves selecting the appropriate Raspberry Pi image, inserting the SD card, and configuring OpenWrt settings. After adjusting LED configurations and network interfaces, I added static leases for Kubernetes nodes. Following a reboot, I reconfigured my Kubernetes Cluster due to IP changes. Troubleshooting involved handling missing wireless menus and resolving issues with Jenkins caused by taints. Now, my Raspberry Pi serves as a versatile OpenWrt Router seamlessly integrated with my Kubernetes Cluster.</description>
    </item>
    <item>
      <title>Jenkins Maven Agent</title>
      <link>https://seehiong.github.io/posts/2020/07/jenkins-maven-agent/</link>
      <pubDate>Fri, 31 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/jenkins-maven-agent/</guid>
      <description>I&amp;rsquo;ve successfully created a Jenkins Maven Agent for my Kubernetes Cluster, significantly improving Maven build times. Configuring Jenkins involved adding a pod template named maven with specific container and volume settings. I created a persistent volume and claims for the Maven repository, reducing build times for subsequent executions. Troubleshooting included resolving errors related to missing persistent volume claims and ownership issues. Now, my Jenkins builds efficiently leverage a local Maven repository within the Kubernetes environment, resulting in faster and more efficient Maven builds.</description>
    </item>
    <item>
      <title>Jenkins Pipeline for K8s Cluster</title>
      <link>https://seehiong.github.io/posts/2020/07/jenkins-pipeline-for-k8s-cluster/</link>
      <pubDate>Fri, 31 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/jenkins-pipeline-for-k8s-cluster/</guid>
      <description>I effortlessly set up a Jenkins Pipeline for my Kubernetes Cluster, enabling seamless continuous integration for my projects. Following my previous post on integrating Jenkins and Gitea, I configured Git and Gitea, creating a declarative Jenkins pipeline. With Gitea webhooks triggering builds on Git commits, I successfully tested the pipeline for a Spring Boot Hello-World application. The pipeline integrates with Git, Maven, and Gitea, ensuring efficient builds and synchronization with each commit. Troubleshooting tips address potential issues, providing a smooth Jenkins experience. Next, I plan to enhance Maven build times in my upcoming guide.</description>
    </item>
    <item>
      <title>Integrating Jenkins and Gitea</title>
      <link>https://seehiong.github.io/posts/2020/07/integrating-jenkins-and-gitea/</link>
      <pubDate>Sun, 26 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/integrating-jenkins-and-gitea/</guid>
      <description>I seamlessly integrated Jenkins and Gitea, establishing full control over my self-hosted continuous integration (CI) environment. I installed the Gitea plugin on Jenkins, configured Gitea, and set up Jenkins to recognize the Gitea organization. The integration allows automatic build triggers upon committing to the Gitea repository. Additionally, I tested the webhook connection for smooth functionality. With this setup, I&amp;rsquo;m ready to dive into the CI workflow for my Spring Boot application in the upcoming post. Stay tuned for more!</description>
    </item>
    <item>
      <title>Helm for K8s Cluster</title>
      <link>https://seehiong.github.io/posts/2020/07/helm-for-k8s-cluster/</link>
      <pubDate>Fri, 24 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/helm-for-k8s-cluster/</guid>
      <description>I&amp;rsquo;ve successfully set up Helm as the package manager for my Raspberry Pi Kubernetes Cluster, enabling easy discovery, sharing, and use of Kubernetes software. After installing Helm, I set up the NGINX Ingress Controller using Helm for external access. Additionally, I configured MetalLB as a layer 2 load balancer to manage external IP addresses. Revisiting my Gitea setup, I updated the service configuration to leverage MetalLB, enhancing the overall scalability and efficiency of my Kubernetes environment on Raspberry Pi. Helm proves to be a valuable tool for managing Kubernetes packages effortlessly.</description>
    </item>
    <item>
      <title>Jenkins for K8s Cluster (II)</title>
      <link>https://seehiong.github.io/posts/2020/07/jenkins-for-k8s-cluster-ii/</link>
      <pubDate>Sun, 19 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/jenkins-for-k8s-cluster-ii/</guid>
      <description>I&amp;rsquo;ve successfully set up Jenkins Agents for my Kubernetes Cluster, enhancing its capabilities for automated build, test, and scalable deployment pipelines. Following Docker image creation for the Jenkins agent on the Raspberry Pi, I configured Jenkins for scalability. Adjustments included setting the inbound agent protocol and configuring Kubernetes cloud settings. Creating Jenkins jobs and scheduling builds demonstrated the functionality, with agents initially suspended and later executing jobs successfully. The troubleshooting tip highlighted the importance of naming the container as jnlp. My Jenkins on Kubernetes Cluster is now fully operational, ready for future pipeline configurations.</description>
    </item>
    <item>
      <title>Jenkins for K8s Cluster (I)</title>
      <link>https://seehiong.github.io/posts/2020/07/jenkins-for-k8s-cluster-i/</link>
      <pubDate>Sun, 12 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/jenkins-for-k8s-cluster-i/</guid>
      <description>I&amp;rsquo;ve successfully set up Jenkins on my Kubernetes Cluster, streamlining build, test, and deployment pipelines. Following a Docker image creation for Jenkins on the Raspberry Pi, I deployed it to the Kubernetes Cluster. Troubleshooting involved building a custom Docker image due to ARM architecture limitations. Additionally, I addressed a service account error by creating the necessary role and role binding. Now, I can access Jenkins and proceed to configure Jenkins Agents for Kubernetes in the next post, enhancing automation within my cluster.</description>
    </item>
    <item>
      <title>Gitea for K8s Cluster</title>
      <link>https://seehiong.github.io/posts/2020/07/gitea-for-k8s-cluster/</link>
      <pubDate>Fri, 10 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/gitea-for-k8s-cluster/</guid>
      <description>In my recent endeavor, I spent 40 minutes setting up Gitea on my Kubernetes Pi cluster, granting me absolute control over personal Git repositories. I seamlessly integrated MySQL, using Docker images and Kubernetes configurations. The meticulous setup involved creating necessary paths on an external HDD, configuring persistent volumes, and ensuring a smooth deployment. I prepared MySQL for Gitea, creating a user, database, and granting privileges. Gitea installation via Docker and subsequent exposure to external access using NodePort were executed flawlessly. A troubleshooting tip addressed a MySQL access issue. Now, my Gitea on Kubernetes Pi Cluster is fully operational for efficient repository management.</description>
    </item>
    <item>
      <title>Kubernetes Cluster on Pi</title>
      <link>https://seehiong.github.io/posts/2020/07/kubernetes-cluster-on-pi/</link>
      <pubDate>Sat, 04 Jul 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/07/kubernetes-cluster-on-pi/</guid>
      <description>I recently spent 70 minutes setting up a Kubernetes Cluster on Raspberry Pi using Ubuntu Server 20.04 LTS. After burning the OS image and configuring a headless setup, I updated the OS, changed the hostname, and enabled memory cgroup. The Docker installation involved setting up external storage and configuring Docker daemon. Installing kubeadm and creating the Kubernetes cluster took an additional 45 minutes. I verified the cluster status, installed networking addons (Calico), and added leaf nodes. Troubleshooting included resolving conntrack and socat issues. Overall, the Raspberry Pi Kubernetes Cluster provides full control over Docker container orchestration.</description>
    </item>
    <item>
      <title>Gitea for MicroK8s Cluster</title>
      <link>https://seehiong.github.io/posts/2020/06/gitea-for-microk8s-cluster/</link>
      <pubDate>Mon, 29 Jun 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/06/gitea-for-microk8s-cluster/</guid>
      <description>I dedicated 45 minutes to set up Gitea on my Raspberry Pi cluster using MicroK8s. Gitea, a self-hosted Git service, grants my team cost savings and enhanced server control. I ensured a smooth installation by preparing MySQL, creating required paths on an external HDD, and configuring persistent volumes. Following MySQL setup, I seamlessly prepared the database and moved on to setting up Gitea with Docker, utilizing a docker-compose.yml file. After injecting images into MicroK8s cache, I exposed Gitea externally using NodePort. Troubleshooting tips were handy, addressing MySQL connection issues. My self-hosted Git service is now ready for efficient collaboration.</description>
    </item>
    <item>
      <title>Docker for MicroK8s Cluster</title>
      <link>https://seehiong.github.io/posts/2020/06/docker-for-microk8s-cluster/</link>
      <pubDate>Sun, 21 Jun 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/06/docker-for-microk8s-cluster/</guid>
      <description>Setting up Docker on my Raspberry Pi Cluster took just 15 minutes. After installing Docker, I added the ubuntu user to the Docker group. Configuring Docker included adjusting the daemon settings for external storage. Testing Docker with a hello-world container went smoothly. To use local images for MicroK8s, I exported and injected the image successfully. Troubleshooting involved resolving daemon start errors, addressing connection issues, and handling permission errors. Formatting the existing NTFS HDD to ext4 and adjusting boot-up settings resolved challenges, making Docker work seamlessly on my Raspberry Pi Cluster.</description>
    </item>
    <item>
      <title>GNU Health</title>
      <link>https://seehiong.github.io/posts/2020/06/gnu-health/</link>
      <pubDate>Sun, 21 Jun 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/06/gnu-health/</guid>
      <description>Exploring GNU Health Embedded on Raspberry Pi 3 for a personal Electronic Medical Record took me 45 minutes. Downloading the image from GNU Health, I utilized Balena Etcher for SD card writing. After attaching peripherals, openSUSE OS booted with the default credentials gnuhealth and freedom. Navigating the GNU Health HMIS, I used admin/gnusolidario to access features like Families and Family Members. Troubleshooting openSUSE involved the root user with the password test. This health system is a potential asset for managing medical information locally, emphasizing personal well-being during the ongoing pandemic.</description>
    </item>
    <item>
      <title>External Storage</title>
      <link>https://seehiong.github.io/posts/2020/06/external-storage/</link>
      <pubDate>Fri, 19 Jun 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/06/external-storage/</guid>
      <description>Expanding my Raspberry Pi Cluster&amp;rsquo;s storage with an external 640GB USB hard disk took 35 minutes. After mounting the external storage and addressing troubleshooting issues, I configured MicroK8s default storage to utilize the added space. Despite encountering errors, a reset and careful configuration solved the problem. Adding leaf nodes for MicroK8s and troubleshooting service unavailability for the dashboard completed the setup. I also disabled and re-enabled addons, ensuring a smooth integration of external storage with my MicroK8s cluster. Accessing the Kubernetes dashboard and checking nodes confirmed a successful expansion.</description>
    </item>
    <item>
      <title>Plasma Bigscreen</title>
      <link>https://seehiong.github.io/posts/2020/06/plasma-bigscreen/</link>
      <pubDate>Sun, 14 Jun 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/06/plasma-bigscreen/</guid>
      <description>Excited to explore, I set up Plasma Bigscreen on my Raspberry Pi 4 Model B 8GB in just 30 minutes. Downloading the beta image and using Win32DiskImager to write it onto the SD card, I encountered an activation step on home.mycroft.ai after booting up. Registering with Mycroft and adding the device, I faced voice recognition issues with Apple earpods and opted for a hard reboot. Although the beta stage led me to wait for improvements, I&amp;rsquo;m eager to retry with a USB microphone. Stay tuned for updates! Troubleshooting TV remote and USB keyboard issues involved username/password and OS update attempts.</description>
    </item>
    <item>
      <title>MicroK8s on Pi 4 8GB (II)</title>
      <link>https://seehiong.github.io/posts/2020/06/microk8s-on-pi-4-8gb-ii/</link>
      <pubDate>Tue, 09 Jun 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/06/microk8s-on-pi-4-8gb-ii/</guid>
      <description>In the second part of my MicroK8s adventure on Raspberry Pi 4 Model B 8GB, I spent 45 minutes adding low-cost Raspberry Pi nodes to enhance cluster performance. Utilizing two older Pi 3B devices with Ubuntu Server (64-bit), I updated the OS, installed MicroK8s, and adjusted configurations. The master node initiated new node creation with &amp;ldquo;sudo microk8s add-node,&amp;rdquo; copying the output to each node. Successful integration was confirmed with &amp;ldquo;microk8s kubectl get node.&amp;rdquo; Excited to explore Kubernetes possibilities and gradually shift CI/CD pipelines to this lightweight cluster. Stay tuned for more on its diverse use cases!</description>
    </item>
    <item>
      <title>MicroK8s on Pi 4 8GB (I)</title>
      <link>https://seehiong.github.io/posts/2020/06/microk8s-on-pi-4-8gb-i/</link>
      <pubDate>Sat, 06 Jun 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/06/microk8s-on-pi-4-8gb-i/</guid>
      <description>I recently spent 40 minutes setting up MicroK8s on my new Raspberry Pi 4 Model B 8GB. Opting for a headless install due to a lack of a microHDMI cable, I used Ubuntu Server (64-bit) for the 64-bit requirements of MicroK8s. After initial setup, including changing the hostname and enabling memory cgroup, I installed MicroK8s, ensuring compatibility by adding my user to the MicroK8s group. Verification and usage of MicroK8s followed, with additional steps for enabling services like the dashboard. Troubleshooting involved switching to a 64-bit OS and finding the Pi&amp;rsquo;s IP using nmap. Excited to explore MicroK8s on my Raspberry Pi!</description>
    </item>
    <item>
      <title>NAS Server</title>
      <link>https://seehiong.github.io/posts/2020/06/nas-server/</link>
      <pubDate>Fri, 05 Jun 2020 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2020/06/nas-server/</guid>
      <description>Repurposing my Raspberry Pi 3B into a NAS server using OpenMediaVault (OMV) was a 90-minute project. I opted for Raspberry Pi OS Lite, ensuring its integrity with MD5 &amp;amp; SHA checksums. Win32DiskImager facilitated OS installation on a 16GB SD card. After powering up, I updated the OS, configured settings, and initiated OMV installation using commands provided by developers. Post-installation, I accessed OMV through the Pi&amp;rsquo;s IP address, configured settings, added a user, mounted an external HDD, created a shared folder, and enabled SMB/CIFS service. Following these steps, I successfully owned a personal OMV on Raspberry Pi!</description>
    </item>
  </channel>
</rss>
