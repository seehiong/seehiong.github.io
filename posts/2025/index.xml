<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts from 2025 on See Hiong&#39;s Blog</title>
    <link>https://seehiong.github.io/posts/2025/</link>
    <description>Recent content in Posts from 2025 on See Hiong&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 06 Jul 2025 20:00:00 +0800</lastBuildDate>
    <atom:link href="https://seehiong.github.io/posts/2025/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Running Bolt.diy with OpenRouter</title>
      <link>https://seehiong.github.io/posts/2025/07/running-bolt.diy-with-openrouter/</link>
      <pubDate>Sun, 06 Jul 2025 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/07/running-bolt.diy-with-openrouter/</guid>
      <description>This post explores running the open-source bolt.diy locally and integrating it with OpenRouter to experiment with various LLMs. I document the development of TextForge—a multi-tool text manipulation app—using one-shot prompts and compare outputs from models like Claude 3 and DeepSeek Chat. The post shares setup steps, performance benchmarks, cost breakdowns, and lessons learned from building a locally hosted, LLM-driven developer tool.</description>
    </item>
    <item>
      <title>Deploying KServe on OKE</title>
      <link>https://seehiong.github.io/posts/2025/05/deploying-kserve-on-oke/</link>
      <pubDate>Mon, 12 May 2025 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/05/deploying-kserve-on-oke/</guid>
      <description>This post demonstrated how to deploy an XGBoost model using KServe on Oracle Kubernetes Engine (OKE). Starting from model upload to Object Storage, we served the model via KServe and exposed it through Istio Gateway. Instead of deploying the frontend in-cluster, we built a Streamlit app hosted on Streamlit Community Cloud, which sends requests to the public inference endpoint. This end-to-end setup showcases a scalable and cloud-native ML deployment pipeline on OCI, separating model serving and user interface layers for flexibility and ease of maintenance.</description>
    </item>
    <item>
      <title>Building a Recommender System</title>
      <link>https://seehiong.github.io/posts/2025/05/building-a-recommender-system/</link>
      <pubDate>Fri, 02 May 2025 10:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/05/building-a-recommender-system/</guid>
      <description>In this post, we walk through the process of building a movie recommender system using deep learning embeddings and PostgreSQL with pgvector. You&amp;rsquo;ll learn how to extract and normalize item features, generate vector embeddings with TensorFlow, store them in a Postgres database, and perform similarity searches to recommend relevant content. The system leverages cosine distance for finding similar items and user preferences, enabling efficient, scalable recommendations.</description>
    </item>
    <item>
      <title>From Model to HDB App</title>
      <link>https://seehiong.github.io/posts/2025/04/from-model-to-hdb-app/</link>
      <pubDate>Mon, 21 Apr 2025 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/04/from-model-to-hdb-app/</guid>
      <description>In this post, I demonstrated how to deploy a Jupyter notebook using the jupyter-tensorflow-full image in Kubeflow, develop an HDB resale price predictor app with Streamlit, and access it via port forwarding. The setup runs locally and showcases how to bring together machine learning, visualization, and interactivity in a seamless development workflow within Kubeflow.</description>
    </item>
    <item>
      <title>Feature Impact on HDB predictions</title>
      <link>https://seehiong.github.io/posts/2025/04/feature-impact-on-hdb-predictions/</link>
      <pubDate>Sun, 13 Apr 2025 10:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/04/feature-impact-on-hdb-predictions/</guid>
      <description>In this post, I explore the impact of different feature sets on XGBoost model performance for HDB resale price prediction. By combining numerical, categorical, and engineered features, I conducted a series of experiments and tracked their performance using MLflow. The results reveal how thoughtful feature engineering and selection can significantly influence metrics like RMSE, MAE, and R²—offering valuable insights into building more accurate predictive models.</description>
    </item>
    <item>
      <title>MNIST Digit Classifier in TensorFlow</title>
      <link>https://seehiong.github.io/posts/2025/04/mnist-digit-classifier-in-tensorflow/</link>
      <pubDate>Sun, 06 Apr 2025 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/04/mnist-digit-classifier-in-tensorflow/</guid>
      <description>In this post, I walk through building a simple feedforward neural network using TensorFlow to classify handwritten digits from the MNIST dataset. From data preprocessing to training, evaluation, and visualizing predictions, this hands-on project reinforces key deep learning concepts covered in Andrew Ng’s course. The model achieved over 97% accuracy on the test set, and I also explored prediction confidence and misclassified samples. A solid foundation for experimenting with more advanced architectures ahead.</description>
    </item>
    <item>
      <title>Chat-Driven Insights with Chart.js</title>
      <link>https://seehiong.github.io/posts/2025/02/chat-driven-insights-with-chart.js/</link>
      <pubDate>Sun, 09 Feb 2025 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/02/chat-driven-insights-with-chart.js/</guid>
      <description>Enhance your Vue.js application by integrating chat capabilities with Chart.js and LLMs like OpenAI and Deepseek-R1. This post walks through adding a chat node to the Micronaut-Optimizer workflow, enabling dynamic interactions with optimization results. Learn how to configure environment variables, connect workflow nodes, and send Chart.js data to LLMs. See it in action with sample inputs and responses, and explore running Deepseek-R1 locally with Ollama.</description>
    </item>
    <item>
      <title>JMC: Java Performance Profiling Simplified</title>
      <link>https://seehiong.github.io/posts/2025/02/jmc-java-performance-profiling-simplified/</link>
      <pubDate>Sun, 02 Feb 2025 20:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/02/jmc-java-performance-profiling-simplified/</guid>
      <description>JDK Mission Control (JMC) is a powerful tool for low-overhead Java application profiling and performance analysis. In this post, I explore JMC’s capabilities while optimizing inference performance for Micronaut-Llama3 with DeepSeek-R1. I walk through setup, profiling with Flight Recorder, and identifying bottlenecks using flame graphs. Key optimizations, such as refining ByteVector operations, significantly enhance performance. A comparison with VisualVM highlights JMC’s advantages, making it the go-to tool for in-depth Java profiling. If you&amp;rsquo;re looking to fine-tune your Java applications, JMC provides essential insights for optimization.</description>
    </item>
    <item>
      <title>Building a Vue.js Frontend for Combinatorial Optimization Problems</title>
      <link>https://seehiong.github.io/posts/2025/01/building-a-vue.js-frontend-for-combinatorial-optimization-problems/</link>
      <pubDate>Sun, 26 Jan 2025 10:00:00 +0800</pubDate>
      <guid>https://seehiong.github.io/posts/2025/01/building-a-vue.js-frontend-for-combinatorial-optimization-problems/</guid>
      <description>In this post, I’ll walk you through the development of a Vue.js frontend application designed to complement my previous work on a flexible optimizer framework built with Micronaut. This frontend provides a visual interface for designing, managing, and optimizing workflows, with a focus on solving combinatorial optimization problems like the Traveling Salesman Problem (TSP). The app features a drag-and-drop UI, enabling users to define optimization problems graphically without relying on tools like Postman. By connecting inputs, transformations, and outputs through Workflow Nodes, users can visualize and compare the performance of backend optimization algorithms across different datasets.</description>
    </item>
  </channel>
</rss>
